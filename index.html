<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plan Highlighter Pro - Video Asset Creator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --anim-duration: 1.5s;
        }

        body { background-color: #0f172a; color: #f8fafc; overflow-x: hidden; }
        
        .canvas-wrapper {
            width: 100%;
            max-width: 380px;
            margin: 0 auto;
            position: relative;
            background-color: #1e293b;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            border: 1px solid #475569;
            overflow: hidden;
            transition: all 0.3s ease;
            aspect-ratio: 9/16;
        }

        #main-canvas { 
            width: 100%; 
            height: 100%; 
            background-size: 100% 100%;
            background-position: center; 
            background-repeat: no-repeat; 
            position: relative; 
        }

        /* Elements */
        .draggable { position: absolute; cursor: move; touch-action: none; display: flex; align-items: center; justify-content: center; border: 2px solid transparent; }
        .draggable.active { border-color: white; border-style: dashed; }
        
        #highlight-box {
            background-color: rgba(239, 68, 68, 0.4);
            border: 2px solid #ef4444;
            transition: opacity 0.4s ease, transform 0.2s ease;
            z-index: 10; /* Above background image but can be moved behind other elements */
        }
        #highlight-box.active { border-color: white; border-style: dashed; box-shadow: 0 0 15px rgba(255,255,255,0.3); }

        .arrow-instance { width: 60px; height: 60px; color: #ef4444; }

        .resize-handle {
            position: absolute; width: 16px; height: 16px; background: white; border: 2px solid #000;
            border-radius: 50%; bottom: -8px; right: -8px; cursor: nwse-resize; z-index: 10;
            display: none;
        }
        .active .resize-handle { display: block; }

        /* Animation Classes */
        .hidden-box { opacity: 0 !important; pointer-events: none; }
        .anim-pulse { animation: pulse-kf var(--anim-duration) infinite ease-in-out; }
        .anim-bounce { animation: bounce-kf var(--anim-duration) infinite; }
        .anim-fade { animation: fade-kf var(--anim-duration) infinite alternate linear; }
        .anim-shake { animation: shake-kf calc(var(--anim-duration) / 3) infinite; }
        .anim-flash { animation: flash-kf calc(var(--anim-duration) / 2) infinite; }
        .anim-spin { animation: spin-kf var(--anim-duration) infinite linear; }
        .anim-zoom { animation: zoom-kf var(--anim-duration) infinite ease-in-out; }
        .anim-float { animation: float-kf var(--anim-duration) infinite ease-in-out; }

        @keyframes pulse-kf { 0%, 100% { transform: scale(1); opacity: 0.4; } 50% { transform: scale(1.1); opacity: 0.8; } }
        @keyframes bounce-kf { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        @keyframes fade-kf { 0% { opacity: 0.1; } 100% { opacity: 0.9; } }
        @keyframes shake-kf { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes flash-kf { 0%, 100% { opacity: 0.8; } 50% { opacity: 0.1; } }
        @keyframes spin-kf { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes zoom-kf { 0%, 100% { transform: scale(0.9); } 50% { transform: scale(1.2); } }
        @keyframes float-kf { 0%, 100% { transform: translate(0, 0); } 33% { transform: translate(5px, -10px); } 66% { transform: translate(-5px, -5px); } }

        .taking-screenshot .resize-handle { display: none !important; }
        .taking-screenshot .active { border-color: transparent !important; box-shadow: none !important; }
        .is-recording #recording-status { display: flex; }

        /* UI Overlays */
        #size-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(15, 23, 42, 0.8);
            color: #94a3b8;
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
            z-index: 50;
            pointer-events: none;
            font-family: monospace;
            display: none;
        }

        .val-badge { 
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
            color: #ef4444;
            font-weight: 700;
            font-size: 10px;
            text-align: right;
        }

        .control-group { @apply flex flex-col gap-1; }
        .label-row { @apply flex justify-between items-center mb-0.5; }

        input[type="range"] {
            height: 4px;
            background: #334155;
            border-radius: 8px;
            appearance: none;
            width: 100%;
        }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            background: #ef4444;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #1e293b;
        }
    </style>
</head>
<body class="p-4 md:p-6 lg:p-10">

    <div class="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-10 items-start">
        
        <!-- Controls Panel -->
        <div class="space-y-4 bg-slate-800/90 p-6 rounded-3xl border border-slate-700 h-fit shadow-2xl">
            <div class="flex justify-between items-center mb-4">
                <h1 class="text-2xl font-black bg-clip-text text-transparent bg-gradient-to-r from-red-500 to-indigo-400 tracking-tight">Plan Highlighter Pro</h1>
                <div id="recording-status" class="hidden items-center gap-2 bg-red-500/20 text-red-400 px-3 py-1 rounded-full text-[10px] font-bold animate-pulse border border-red-500/30 uppercase tracking-widest">
                    Recording
                </div>
            </div>

            <div class="space-y-3">
                <!-- 1. Label Settings -->
                <div class="p-4 bg-slate-900/60 rounded-xl border border-slate-700 space-y-3">
                    <label class="text-[9px] uppercase font-bold text-slate-500 tracking-widest block">1. Label</label>
                    <div class="flex gap-2">
                        <input type="text" id="labelInput" value="Zone 06" class="flex-1 bg-slate-800 border border-slate-700 rounded-lg px-3 py-2 text-xs outline-none focus:ring-1 focus:ring-red-500/50">
                        <label class="flex items-center gap-1.5 text-[10px] cursor-pointer select-none bg-slate-800 px-3 rounded-lg border border-slate-700 hover:bg-slate-700">
                            <input type="checkbox" id="showLabel" checked class="accent-red-500 w-3 h-3"> <span class="text-slate-400 font-bold">Show</span>
                        </label>
                        <input type="color" id="labelColor" value="#ffffff" class="h-9 w-12 bg-transparent cursor-pointer rounded-lg border border-slate-700">
                    </div>
                    <div class="control-group">
                        <div class="label-row">
                            <span class="text-[10px] font-bold text-slate-400">Font Size</span>
                            <span id="fontSizeVal" class="val-badge text-[9px]">14px</span>
                        </div>
                        <input type="range" id="fontSize" min="10" max="60" value="14" class="h-1">
                    </div>
                </div>

                <!-- 2. UI Elements Settings -->
                <div class="p-4 bg-slate-900/60 rounded-xl border border-slate-700 space-y-3">
                    <label class="text-[9px] uppercase font-bold text-slate-500 tracking-widest block">2. Elements</label>
                    <div class="grid grid-cols-2 gap-2">
                        <select id="arrowType" class="bg-slate-800 border border-slate-700 rounded-lg px-2 py-2 text-[10px] outline-none cursor-pointer">
                            <option value="simple">Arrow</option>
                            <option value="diagonal">Diagonal</option>
                            <option value="right">Right</option>
                            <option value="curved">Curved</option>
                            <option value="double">Double</option>
                        </select>
                        <div class="flex gap-1">
                            <button id="addArrow" class="flex-1 bg-green-600 hover:bg-green-500 py-2 rounded-lg text-[9px] font-black uppercase">Add</button>
                            <button id="reuseArrow" class="flex-1 bg-green-700 hover:bg-green-600 py-2 rounded-lg text-[9px] font-black uppercase">Reuse</button>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="document.getElementById('svgFileInput').click()" class="bg-indigo-600 hover:bg-indigo-500 py-2 rounded-lg text-[9px] font-black uppercase">Upload SVG</button>
                        <div class="flex gap-1">
                            <button id="addCustomSvg" class="flex-1 bg-indigo-600 hover:bg-indigo-500 py-2 rounded-lg text-[9px] font-black uppercase">Add</button>
                            <button id="reuseSvg" class="flex-1 bg-indigo-700 hover:bg-indigo-600 py-2 rounded-lg text-[9px] font-black uppercase">Reuse</button>
                        </div>
                    </div>
                    <textarea id="svgTextInput" placeholder="Paste SVG..." class="w-full bg-slate-800 border border-slate-700 rounded-lg text-[9px] py-1.5 px-2 outline-none h-16 font-mono text-slate-300 placeholder-slate-500 resize-none"></textarea>
                    <input type="file" id="svgFileInput" accept=".svg,image/svg+xml" class="hidden">
                    <div class="flex gap-2 pt-1 border-t border-slate-800">
                        <div class="flex-1">
                            <div class="flex items-center justify-between mb-1">
                                <span class="text-[9px] font-bold text-slate-400">Color (RGBA)</span>
                                <div class="flex items-center gap-1.5">
                                    <input type="color" id="boxColor" value="#ef4444" class="h-6 w-10 bg-transparent cursor-pointer rounded border border-slate-700">
                                    <input type="text" id="rgbaInput" value="rgba(239,68,68,0.4)" placeholder="rgba(r,g,b,a)" class="text-[8px] font-mono text-slate-300 bg-slate-800 px-1.5 py-0.5 rounded border border-slate-700 w-24 outline-none focus:ring-1 focus:ring-red-500/50">
                                </div>
                            </div>
                            <div class="control-group">
                                <div class="label-row">
                                    <span class="text-[9px] font-bold text-slate-400">Opacity</span>
                                    <span id="boxOpacityVal" class="val-badge text-[9px]">0.4</span>
                                </div>
                                <input type="range" id="boxOpacity" min="0" max="1" step="0.05" value="0.4" class="h-1">
                            </div>
                        </div>
                        <div class="flex-1">
                            <div class="label-row mb-1">
                                <span class="text-[9px] font-bold text-slate-400">Z-Index</span>
                                <span id="zIndexVal" class="val-badge text-[9px]">100</span>
                            </div>
                            <input type="range" id="zIndex" min="1" max="1000" value="100" class="h-1">
                        </div>
                    </div>
                    <div class="flex gap-1 pt-1 border-t border-slate-800">
                        <button id="deleteSelected" class="flex-1 bg-red-700 hover:bg-red-600 py-2 rounded-lg text-[9px] font-black uppercase">Delete</button>
                        <button id="bringToFront" class="flex-1 bg-blue-600 hover:bg-blue-500 py-2 rounded-lg text-[9px] font-black uppercase">Front</button>
                        <button id="sendToBack" class="flex-1 bg-blue-700 hover:bg-blue-600 py-2 rounded-lg text-[9px] font-black uppercase">Back</button>
                    </div>
                </div>

                <!-- 3. Plan Image -->
                <div class="p-4 bg-slate-900/60 rounded-xl border border-slate-700 space-y-3">
                    <label class="text-[9px] uppercase font-bold text-slate-500 tracking-widest block">3. Plan Image</label>
                    <button onclick="document.getElementById('imageInput').click()" class="w-full bg-slate-100 text-slate-900 py-2.5 rounded-lg text-[10px] font-black uppercase hover:bg-white transition-all">Upload</button>
                    <input type="file" id="imageInput" accept="image/*" class="hidden">
                    <div class="flex items-center justify-between text-[9px] text-slate-400 pt-1 border-t border-slate-800">
                        <span>Size:</span>
                        <span id="resBadge" class="font-bold">Ready</span>
                    </div>
                </div>

                <!-- 4. Animation Settings -->
                <div class="p-4 bg-slate-900/60 rounded-xl border border-slate-700 space-y-3">
                    <label class="text-[9px] uppercase font-bold text-slate-500 tracking-widest block">4. Animation</label>
                    <div class="flex gap-2">
                        <select id="animType" class="flex-1 bg-slate-800 border border-slate-700 rounded-lg py-2 text-[10px] outline-none cursor-pointer">
                            <option value="anim-pulse">Pulse</option>
                            <option value="anim-bounce">Bounce</option>
                            <option value="anim-fade">Fade</option>
                            <option value="anim-shake">Shake</option>
                            <option value="anim-flash">Flash</option>
                            <option value="anim-spin">Spin</option>
                            <option value="anim-zoom">Zoom</option>
                            <option value="anim-float">Float</option>
                        </select>
                        <button id="btnPulse" class="bg-slate-700 hover:bg-red-600 px-3 py-2 rounded-lg text-[9px] font-black uppercase">Loop</button>
                    </div>
                    <div class="control-group">
                        <div class="label-row">
                            <span class="text-[10px] font-bold text-slate-400">Duration</span>
                            <span id="animDurationVal" class="val-badge text-[9px]">1.5s</span>
                        </div>
                        <input type="range" id="animDuration" min="0.2" max="5.0" step="0.1" value="1.5" class="h-1">
                    </div>
                    <div class="flex gap-1 pt-1 border-t border-slate-800">
                        <button id="btnToggle" class="flex-1 bg-slate-700 hover:bg-slate-600 py-2 rounded-lg text-[9px] font-black uppercase">Hide Box</button>
                        <button id="btnPulseOnce" class="flex-1 bg-slate-700 hover:bg-slate-600 py-2 rounded-lg text-[9px] font-black uppercase">Play Once</button>
                    </div>
                </div>

                <!-- 5. Video Recording -->
                <div class="p-4 bg-slate-900/60 rounded-xl border border-slate-700 space-y-3">
                    <label class="text-[9px] uppercase font-bold text-slate-500 tracking-widest block">5. Recording</label>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="btnStartRecord" class="bg-red-600 hover:bg-red-500 py-3 rounded-lg text-[10px] font-black uppercase flex items-center justify-center gap-2">
                            <span class="w-2 h-2 bg-white rounded-full animate-pulse"></span> Record
                        </button>
                        <button id="btnMagicRecord" class="bg-indigo-600 hover:bg-indigo-500 py-3 rounded-lg text-[10px] font-black uppercase">Auto Loop</button>
                    </div>
                    <div class="pt-1 border-t border-slate-800 space-y-2">
                        <div class="control-group">
                            <div class="label-row">
                                <span class="text-[9px] font-bold text-slate-400">Quality Preset</span>
                                <span id="qualityPresetVal" class="val-badge text-[9px]">1080p</span>
                            </div>
                            <select id="qualityPreset" class="w-full bg-slate-800 border border-slate-700 rounded-lg py-2 text-[10px] outline-none cursor-pointer">
                                <option value="720">720p (1280x720)</option>
                                <option value="1080" selected>1080p (1920x1080)</option>
                                <option value="1440">1440p (2560x1440)</option>
                                <option value="4k">4K (3840x2160)</option>
                                <option value="native">Native (Image Size)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <div class="label-row">
                                <span class="text-[9px] font-bold text-slate-400">Bitrate (Mbps)</span>
                                <span id="bitrateVal" class="val-badge text-[9px]">10</span>
                            </div>
                            <input type="range" id="bitrate" min="1" max="50" step="1" value="10" class="h-1">
                        </div>
                        <div class="control-group">
                            <div class="label-row">
                                <span class="text-[9px] font-bold text-slate-400">Frame Rate (fps)</span>
                                <span id="fpsVal" class="val-badge text-[9px]">30</span>
                            </div>
                            <input type="range" id="fps" min="15" max="60" step="1" value="30" class="h-1">
                        </div>
                        <div class="text-[8px] text-slate-500 pt-1 border-t border-slate-800">
                            <div class="flex justify-between">
                                <span>Output:</span>
                                <span id="qualityInfo" class="font-bold text-slate-400">1920x1080 @ 30fps</span>
                            </div>
                        </div>
                    </div>
                    <div class="flex gap-2 pt-1 border-t border-slate-800">
                        <button id="btnDownload" class="flex-1 bg-emerald-700 hover:bg-emerald-600 py-2.5 rounded-lg text-[9px] font-black uppercase">Save PNG</button>
                        <button id="btnReset" class="flex-1 bg-slate-700 hover:bg-red-900/40 py-2.5 rounded-lg text-[9px] font-black uppercase">Reset</button>
                    </div>
                </div>

                <!-- Element Properties (Size, Position, Rotation) -->
                <div class="p-4 bg-slate-900/60 rounded-xl border border-slate-700 space-y-3">
                    <label class="text-[9px] uppercase font-bold text-slate-500 tracking-widest block">Properties</label>
                    <div class="grid grid-cols-2 gap-2">
                        <div class="control-group">
                            <div class="label-row">
                                <span class="text-[9px] font-bold text-slate-400">W</span>
                                <span id="rectWidthVal" class="val-badge text-[9px]">100px</span>
                            </div>
                            <input type="range" id="rectWidth" min="10" max="500" value="100" class="h-1">
                        </div>
                        <div class="control-group">
                            <div class="label-row">
                                <span class="text-[9px] font-bold text-slate-400">H</span>
                                <span id="rectHeightVal" class="val-badge text-[9px]">100px</span>
                            </div>
                            <input type="range" id="rectHeight" min="10" max="800" value="100" class="h-1">
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <div class="control-group">
                            <div class="label-row">
                                <span class="text-[9px] font-bold text-slate-400">X</span>
                                <span id="posXVal" class="val-badge text-[9px]">0</span>
                            </div>
                            <input type="range" id="posX" min="0" max="500" value="0" class="h-1">
                        </div>
                        <div class="control-group">
                            <div class="label-row">
                                <span class="text-[9px] font-bold text-slate-400">Y</span>
                                <span id="posYVal" class="val-badge text-[9px]">0</span>
                            </div>
                            <input type="range" id="posY" min="0" max="800" value="0" class="h-1">
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="label-row">
                            <span class="text-[9px] font-bold text-slate-400">Rotation</span>
                            <span id="rotationVal" class="val-badge text-[9px]">0°</span>
                        </div>
                        <input type="range" id="rotation" min="0" max="360" value="0" class="h-1">
                    </div>
                    <div class="control-group pt-1 border-t border-slate-800">
                        <div class="label-row">
                            <span class="text-[9px] font-bold text-slate-400">Border</span>
                            <span id="borderWidthVal" class="val-badge text-[9px]">2px</span>
                        </div>
                        <input type="range" id="borderWidth" min="0" max="30" value="2" class="h-1">
                    </div>
                </div>
            </div>
        </div>

        <!-- Preview Canvas -->
        <div class="flex flex-col items-center sticky top-8 lg:mt-6">
            <div class="canvas-wrapper ring-8 ring-slate-800/50" id="canvas-wrapper">
                <div id="size-badge">0 x 0</div>
                <div id="main-canvas">
                    <div id="highlight-box" class="draggable active" style="width: 100px; height: 100px; top: 40%; left: 30%;">
                        <span id="boxLabel" class="text-white font-bold select-none pointer-events-none text-center">Zone 06</span>
                        <div class="resize-handle"></div>
                    </div>
                </div>
            </div>
            <div class="mt-6 flex flex-col items-center gap-2 text-center">
                <div class="flex items-center gap-2 bg-slate-800 px-4 py-1.5 rounded-full border border-slate-700">
                    <span id="res-badge" class="text-slate-300 text-[10px] uppercase font-black tracking-[0.2em]">Ready</span>
                </div>
                <p class="text-slate-600 text-[9px] font-medium max-w-[300px]">Project adjusts to image aspect ratio. All elements are tracked in export.</p>
            </div>
        </div>
    </div>

    <canvas id="record-canvas" width="720" height="1280" style="display:none;"></canvas>

    <script>
        const ARROW_PATHS = {
            simple: "M11 5V14L7.5 10.5L6 12L12 18L18 12L16.5 10.5L13 14V5H11Z",
            diagonal: "M19 19V9L15.5 12.5L12 9L5 16L6.5 17.5L12 12L14 14L10 18L11.5 19.5L15 16V19H19Z",
            right: "M5 13h12.5l-3.5 3.5 1.5 1.5 6-6-6-6-1.5 1.5 3.5 3.5H5v2z",
            curved: "M20 12c0-4.4-3.6-8-8-8S4 7.6 4 12v4l-2-2-1.4 1.4L4.3 19l3.7-3.6L6.6 14l-2.6 2.6v-4.6c0-3.3 2.7-6 6-6s6 2.7 6 6H20z",
            double: "M21 12l-4-4v3H7V8l-4 4 4 4v-3h10v3l4-4z"
        };

        let activeElement = document.getElementById('highlight-box');
        let elements = [activeElement];
        let bgImage = null;

        const els = {
            imageInput: document.getElementById('imageInput'),
            mainCanvas: document.getElementById('main-canvas'),
            canvasWrapper: document.getElementById('canvas-wrapper'),
            sizeBadge: document.getElementById('size-badge'),
            resBadge: document.getElementById('res-badge'),
            labelInput: document.getElementById('labelInput'),
            showLabel: document.getElementById('showLabel'),
            fontSize: document.getElementById('fontSize'),
            fontSizeVal: document.getElementById('fontSizeVal'),
            boxColor: document.getElementById('boxColor'),
            boxOpacity: document.getElementById('boxOpacity'),
            boxOpacityVal: document.getElementById('boxOpacityVal'),
            rgbaInput: document.getElementById('rgbaInput'),
            borderWidth: document.getElementById('borderWidth'),
            borderWidthVal: document.getElementById('borderWidthVal'),
            rectWidth: document.getElementById('rectWidth'),
            rectWidthVal: document.getElementById('rectWidthVal'),
            rectHeight: document.getElementById('rectHeight'),
            rectHeightVal: document.getElementById('rectHeightVal'),
            posX: document.getElementById('posX'),
            posXVal: document.getElementById('posXVal'),
            posY: document.getElementById('posY'),
            posYVal: document.getElementById('posYVal'),
            animDuration: document.getElementById('animDuration'),
            animDurationVal: document.getElementById('animDurationVal'),
            animType: document.getElementById('animType'),
            arrowType: document.getElementById('arrowType'),
            addArrow: document.getElementById('addArrow'),
            deleteSelected: document.getElementById('deleteSelected'),
            btnMagic: document.getElementById('btnMagicRecord'),
            btnStart: document.getElementById('btnStartRecord'),
            btnDownload: document.getElementById('btnDownload'),
            recordCanvas: document.getElementById('record-canvas'),
            btnPulse: document.getElementById('btnPulse'),
            btnToggle: document.getElementById('btnToggle'),
            btnPulseOnce: document.getElementById('btnPulseOnce'),
            btnReset: document.getElementById('btnReset'),
            boxLabel: document.getElementById('boxLabel'),
            svgFileInput: document.getElementById('svgFileInput'),
            svgTextInput: document.getElementById('svgTextInput'),
            addCustomSvg: document.getElementById('addCustomSvg'),
            bringToFront: document.getElementById('bringToFront'),
            sendToBack: document.getElementById('sendToBack'),
            labelColor: document.getElementById('labelColor'),
            zIndex: document.getElementById('zIndex'),
            zIndexVal: document.getElementById('zIndexVal'),
            rotation: document.getElementById('rotation'),
            rotationVal: document.getElementById('rotationVal'),
            reuseArrow: document.getElementById('reuseArrow'),
            reuseSvg: document.getElementById('reuseSvg'),
            qualityPreset: document.getElementById('qualityPreset'),
            qualityPresetVal: document.getElementById('qualityPresetVal'),
            bitrate: document.getElementById('bitrate'),
            bitrateVal: document.getElementById('bitrateVal'),
            fps: document.getElementById('fps'),
            fpsVal: document.getElementById('fpsVal'),
            qualityInfo: document.getElementById('qualityInfo')
        };

        // Quality presets (width, height)
        const QUALITY_PRESETS = {
            '720': [1280, 720],
            '1080': [1920, 1080],
            '1440': [2560, 1440],
            '4k': [3840, 2160]
        };

        // Saved elements for reuse
        let savedArrows = [];
        let savedSvgs = [];
        
        const ctx = els.recordCanvas.getContext('2d');
        // Enable high-quality image rendering
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        function setActive(el) {
            const wasAlreadyActive = activeElement === el;
            elements.forEach(e => e.classList.remove('active'));
            activeElement = el;
            activeElement.classList.add('active');

            const style = window.getComputedStyle(el);
            // Extract opacity from color (rgba) instead of element opacity
            let extractedOpacity = 1;
            if (el.id === 'highlight-box') {
                const bgColor = style.backgroundColor;
                // Try to extract alpha from rgba background color
                const rgbaMatch = bgColor.match(/rgba?\s*\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*(?:,\s*([\d.]+))?\s*\)/);
                if (rgbaMatch && rgbaMatch[1]) {
                    extractedOpacity = parseFloat(rgbaMatch[1]);
                }
            } else {
                const elementColor = style.color;
                // Try to extract alpha from rgba color
                const rgbaMatch = elementColor.match(/rgba?\s*\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*(?:,\s*([\d.]+))?\s*\)/);
                if (rgbaMatch && rgbaMatch[1]) {
                    extractedOpacity = parseFloat(rgbaMatch[1]);
                }
            }
            els.boxOpacity.value = extractedOpacity;
            els.boxOpacityVal.textContent = extractedOpacity.toFixed(2);
            
            els.posX.value = el.offsetLeft;
            els.posXVal.textContent = el.offsetLeft;
            els.posY.value = el.offsetTop;
            els.posYVal.textContent = el.offsetTop;
            
            els.rectWidth.value = el.offsetWidth;
            els.rectWidthVal.textContent = el.offsetWidth + 'px';
            els.rectHeight.value = el.offsetHeight;
            els.rectHeightVal.textContent = el.offsetHeight + 'px';

            // Rotation
            const transform = style.transform;
            let rotation = 0;
            if (transform && transform !== 'none') {
                const matrix = transform.match(/matrix\((.+)\)/);
                if (matrix) {
                    const v = matrix[1].split(', ').map(parseFloat);
                    rotation = Math.round(Math.atan2(v[1], v[0]) * (180 / Math.PI));
                    if (rotation < 0) rotation += 360;
                }
            }
            els.rotation.value = rotation;
            els.rotationVal.textContent = rotation + '°';

            // Z-Index
            const zIndex = parseInt(style.zIndex) || parseInt(el.style.zIndex) || 100;
            els.zIndex.value = zIndex;
            els.zIndexVal.textContent = zIndex;

            // Only update colors if switching to a different element (not if already active)
            if (!wasAlreadyActive) {
                if (el.id === 'highlight-box') {
                    const borderColor = style.borderColor;
                    if (borderColor && borderColor !== 'rgba(0, 0, 0, 0)') {
                        els.boxColor.value = rgbToHex(borderColor);
                    }
                    els.borderWidth.value = parseInt(style.borderWidth);
                    els.borderWidthVal.textContent = els.borderWidth.value + 'px';
                    
                    // Label Sync
                    els.fontSize.value = parseInt(els.boxLabel.style.fontSize) || 14;
                    els.fontSizeVal.textContent = els.fontSize.value + 'px';
                    els.labelInput.value = els.boxLabel.textContent;
                    const labelColor = window.getComputedStyle(els.boxLabel).color;
                    if (labelColor && labelColor !== 'rgba(0, 0, 0, 0)') {
                        els.labelColor.value = rgbToHex(labelColor);
                    }
                } else {
                    const elementColor = style.color;
                    if (elementColor && elementColor !== 'rgba(0, 0, 0, 0)') {
                        els.boxColor.value = rgbToHex(elementColor);
                    }
                    els.borderWidth.value = el.dataset.arrowSize || 2;
                    els.borderWidthVal.textContent = els.borderWidth.value + 'px';
                    els.arrowType.value = el.dataset.type || 'simple';
                }
            }
            updateRgbaDisplay();
        }

        function rgbToHex(rgb) {
            if (!rgb || rgb === 'rgba(0, 0, 0, 0)') return '#ef4444';
            const vals = rgb.match(/\d+/g);
            if (!vals) return '#ef4444';
            return "#" + vals.slice(0, 3).map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
        }

        function updateRgbaDisplay() {
            if (els.rgbaInput) {
                const hex = els.boxColor.value;
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                const a = parseFloat(els.boxOpacity.value);
                els.rgbaInput.value = `rgba(${r},${g},${b},${a.toFixed(2)})`;
            }
        }

        function parseRgbaInput(value) {
            if (!value || !value.trim()) return false;
            
            // Try rgba/rgb format: rgba(255,0,0,0.5) or rgb(255,0,0)
            const rgbaMatch = value.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+))?\s*\)/i);
            if (rgbaMatch) {
                const r = parseInt(rgbaMatch[1]);
                const g = parseInt(rgbaMatch[2]);
                const b = parseInt(rgbaMatch[3]);
                const a = rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1;
                
                // Convert RGB to hex
                const hex = "#" + [r, g, b].map(x => {
                    const hex = Math.min(255, Math.max(0, x)).toString(16);
                    return hex.length === 1 ? "0" + hex : hex;
                }).join('');
                
                // Update color and opacity
                els.boxColor.value = hex;
                els.boxOpacity.value = Math.min(1, Math.max(0, a));
                els.boxOpacityVal.textContent = a.toFixed(2);
                updateRgbaDisplay(); // Normalize format
                updateSelected();
                return true;
            }
            
            // Try hex with alpha: #rrggbbaa or #rgba
            const hexAlphaMatch = value.match(/#([0-9a-f]{8}|[0-9a-f]{4})/i);
            if (hexAlphaMatch) {
                const hex = hexAlphaMatch[1];
                let r, g, b, a;
                
                if (hex.length === 8) {
                    // #rrggbbaa format
                    r = parseInt(hex.slice(0, 2), 16);
                    g = parseInt(hex.slice(2, 4), 16);
                    b = parseInt(hex.slice(4, 6), 16);
                    a = parseInt(hex.slice(6, 8), 16) / 255;
                } else if (hex.length === 4) {
                    // #rgba format (short)
                    r = parseInt(hex[0] + hex[0], 16);
                    g = parseInt(hex[1] + hex[1], 16);
                    b = parseInt(hex[2] + hex[2], 16);
                    a = parseInt(hex[3] + hex[3], 16) / 255;
                }
                
                const hexColor = "#" + [r, g, b].map(x => {
                    const h = Math.min(255, Math.max(0, x)).toString(16);
                    return h.length === 1 ? "0" + h : h;
                }).join('');
                
                currentColor = hexColor;
                els.boxOpacity.value = Math.min(1, Math.max(0, a));
                els.boxOpacityVal.textContent = a.toFixed(2);
                updateRgbaDisplay();
                updateSelected();
                return true;
            }
            
            // Try regular hex: #rrggbb or #rgb
            const hexMatch = value.match(/#([0-9a-f]{6}|[0-9a-f]{3})/i);
            if (hexMatch) {
                const hex = hexMatch[1];
                let r, g, b;
                
                if (hex.length === 6) {
                    r = parseInt(hex.slice(0, 2), 16);
                    g = parseInt(hex.slice(2, 4), 16);
                    b = parseInt(hex.slice(4, 6), 16);
                } else {
                    r = parseInt(hex[0] + hex[0], 16);
                    g = parseInt(hex[1] + hex[1], 16);
                    b = parseInt(hex[2] + hex[2], 16);
                }
                
                const hexColor = "#" + [r, g, b].map(x => {
                    const h = Math.min(255, Math.max(0, x)).toString(16);
                    return h.length === 1 ? "0" + h : h;
                }).join('');
                
                els.boxColor.value = hexColor;
                // Keep existing opacity
                updateRgbaDisplay();
                updateSelected();
                return true;
            }
            
            return false;
        }

        const createArrow = (type, color, size) => {
            const arrow = document.createElement('div');
            arrow.className = 'draggable arrow-instance active';
            arrow.style.top = '15%';
            arrow.style.left = '15%';
            arrow.style.color = color || els.boxColor.value;
            arrow.style.zIndex = els.zIndex.value || '100';
            arrow.dataset.type = type || els.arrowType.value;
            arrow.dataset.arrowSize = size || els.borderWidth.value;
            arrow.innerHTML = `<svg viewBox="0 0 24 24" fill="currentColor" class="w-full h-full drop-shadow-lg"><path d="${ARROW_PATHS[type || els.arrowType.value]}" /></svg><div class="resize-handle"></div>`;
            els.mainCanvas.appendChild(arrow);
            elements.push(arrow);
            setupDraggable(arrow);
            setActive(arrow);
            return arrow;
        };

        els.addArrow.addEventListener('click', () => {
            const arrow = createArrow();
            // Save arrow template
            savedArrows.push({
                type: els.arrowType.value,
                color: els.boxColor.value,
                size: els.borderWidth.value
            });
        });

        els.reuseArrow.addEventListener('click', () => {
            if (savedArrows.length > 0) {
                const last = savedArrows[savedArrows.length - 1];
                createArrow(last.type, last.color, last.size);
            } else {
                createArrow(); // Create new if none saved
            }
        });

        // Helper function to replace currentColor with actual color in SVG XML
        const replaceCurrentColorInSvgXml = (svgXml, actualColor) => {
            // Replace fill="currentColor" and fill='currentColor' with actual color
            svgXml = svgXml.replace(/fill=["']currentColor["']/gi, `fill="${actualColor}"`);
            // Replace stroke="currentColor" and stroke='currentColor' with actual color
            svgXml = svgXml.replace(/stroke=["']currentColor["']/gi, `stroke="${actualColor}"`);
            return svgXml;
        };

        const addCustomSvgElement = (svgContent) => {
            const svgDiv = document.createElement('div');
            svgDiv.className = 'draggable arrow-instance active';
            svgDiv.style.top = '15%';
            svgDiv.style.left = '15%';
            // Apply opacity to color (rgba), not element opacity
            const rgbaColor = hexToRgba(els.boxColor.value, els.boxOpacity.value);
            svgDiv.style.color = rgbaColor;
            svgDiv.style.opacity = '1'; // Full element opacity, color has opacity
            svgDiv.style.width = '60px';
            svgDiv.style.height = '60px';
            svgDiv.style.zIndex = '100'; // Ensure it's above background
            svgDiv.dataset.customSvg = 'true';
            svgDiv.dataset.svgContent = svgContent;
            
            // Parse and sanitize SVG content
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
            const parsedSvg = svgDoc.querySelector('svg');
            
            if (parsedSvg) {
                // Extract viewBox for proper scaling
                const viewBox = parsedSvg.getAttribute('viewBox') || '0 0 24 24';
                parsedSvg.setAttribute('viewBox', viewBox);
                parsedSvg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                
                // Remove class attributes that might interfere (like Tailwind classes)
                parsedSvg.removeAttribute('class');
                
                // Update fill/stroke to currentColor if they exist, but preserve the SVG structure
                // Only update if fill is not "none"
                if (parsedSvg.hasAttribute('fill')) {
                    const fillValue = parsedSvg.getAttribute('fill');
                    if (fillValue !== 'none') {
                        parsedSvg.setAttribute('fill', 'currentColor');
                    }
                }
                // Update child elements with fill (but not if fill="none")
                parsedSvg.querySelectorAll('[fill]').forEach(el => {
                    const fillValue = el.getAttribute('fill');
                    if (fillValue && fillValue !== 'none') {
                        el.setAttribute('fill', 'currentColor');
                    }
                });
                
                // Update stroke to currentColor if stroke is used (but not if stroke="none")
                if (parsedSvg.hasAttribute('stroke')) {
                    const strokeValue = parsedSvg.getAttribute('stroke');
                    if (strokeValue && strokeValue !== 'none') {
                        parsedSvg.setAttribute('stroke', 'currentColor');
                    }
                }
                // Update child elements with stroke (but not if stroke="none")
                parsedSvg.querySelectorAll('[stroke]').forEach(el => {
                    const strokeValue = el.getAttribute('stroke');
                    if (strokeValue && strokeValue !== 'none') {
                        el.setAttribute('stroke', 'currentColor');
                    }
                });
                
                // Get the SVG HTML and insert it
                const svgHtml = parsedSvg.outerHTML;
                svgDiv.innerHTML = svgHtml + '<div class="resize-handle"></div>';
                
                // Now get the actual DOM element for setting style
                const svgElement = svgDiv.querySelector('svg');
                if (svgElement && svgElement.style) {
                    svgElement.style.width = '100%';
                    svgElement.style.height = '100%';
                }
                
                // Pre-load SVG as image for video recording - store the Image object directly
                // IMPORTANT: Replace currentColor with actual color value for image rendering
                let svgData = new XMLSerializer().serializeToString(svgElement);
                const actualColor = svgDiv.style.color || rgbaColor; // Use current color from element
                svgData = replaceCurrentColorInSvgXml(svgData, actualColor);
                const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);
                const img = new Image();
                img.onload = () => {
                    // Store both the URL and the loaded Image object
                    svgDiv.dataset.svgImageData = url;
                    svgDiv.dataset.svgImage = 'loaded'; // Mark as loaded
                    // Store the Image object itself for synchronous drawing
                    svgDiv._cachedSvgImage = img;
                };
                img.onerror = () => {
                    console.error('Failed to load SVG image');
                };
                img.src = url;
            } else {
                // Fallback if parsing fails
                svgDiv.innerHTML = svgContent + '<div class="resize-handle"></div>';
            }
            
            els.mainCanvas.appendChild(svgDiv);
            elements.push(svgDiv);
            setupDraggable(svgDiv);
            setActive(svgDiv);
        };

        els.svgFileInput.addEventListener('change', e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = ev => {
                    const svgContent = ev.target.result;
                    els.svgTextInput.value = svgContent;
                    addCustomSvgElement(svgContent);
                    e.target.value = ''; // Reset file input
                };
                reader.readAsText(file);
            }
        });

        els.addCustomSvg.addEventListener('click', () => {
            const svgContent = els.svgTextInput.value.trim();
            if (svgContent) {
                addCustomSvgElement(svgContent);
                // Save SVG template
                savedSvgs.push({
                    content: svgContent,
                    color: els.boxColor.value,
                    opacity: els.boxOpacity.value
                });
                els.svgTextInput.value = ''; // Clear after adding
            }
        });

        els.reuseSvg.addEventListener('click', () => {
            if (savedSvgs.length > 0) {
                const last = savedSvgs[savedSvgs.length - 1];
                els.boxColor.value = last.color;
                els.boxOpacity.value = last.opacity;
                updateRgbaDisplay();
                addCustomSvgElement(last.content);
            } else {
                alert('No saved SVG. Add one first.');
            }
        });

        els.deleteSelected.addEventListener('click', () => {
            if (activeElement && activeElement.id !== 'highlight-box') {
                activeElement.remove();
                elements = elements.filter(e => e !== activeElement);
                setActive(document.getElementById('highlight-box'));
            }
        });

        els.bringToFront.addEventListener('click', () => {
            if (activeElement && activeElement.parentElement) {
                // Move element to the end of parent's children (top of stack)
                activeElement.parentElement.appendChild(activeElement);
                // Also update z-index for visual feedback
                activeElement.style.zIndex = '1000';
            }
        });

        els.sendToBack.addEventListener('click', () => {
            if (activeElement && activeElement.parentElement) {
                // Get the highlight-box as reference for back position
                const highlightBox = document.getElementById('highlight-box');
                if (highlightBox && activeElement.id !== 'highlight-box') {
                    // Insert before highlight-box (but highlight-box stays at back)
                    highlightBox.parentElement.insertBefore(activeElement, highlightBox.nextSibling);
                    activeElement.style.zIndex = '10'; // Minimum z-index above background
                } else {
                    // If highlight-box is selected, just ensure it's first but still above background
                    activeElement.parentElement.insertBefore(activeElement, activeElement.parentElement.firstChild);
                    activeElement.style.zIndex = '5'; // Keep above background image
                }
            }
        });

        els.imageInput.addEventListener('change', e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = ev => {
                    const dataUrl = ev.target.result;
                    bgImage = new Image();
                    bgImage.onload = () => {
                        els.canvasWrapper.style.aspectRatio = `${bgImage.width} / ${bgImage.height}`;
                        els.mainCanvas.style.backgroundImage = `url(${dataUrl})`;
                        
                        // Apply quality preset or use native size
                        updateRecordCanvasSize();
                        
                        const rect = els.canvasWrapper.getBoundingClientRect();
                        els.posX.max = rect.width;
                        els.posY.max = rect.height;
                        els.rectWidth.max = rect.width;
                        els.rectHeight.max = rect.height;
                        
                        els.resBadge.textContent = `${bgImage.width} x ${bgImage.height}`;
                        els.sizeBadge.textContent = `${bgImage.width} x ${bgImage.height}`;
                        els.sizeBadge.style.display = 'block';
                        updateQualityInfo();
                        setActive(document.getElementById('highlight-box'));
                    };
                    bgImage.src = dataUrl;
                };
                reader.readAsDataURL(file);
            }
        });

        // Fix: Update text immediately on typing
        els.labelInput.addEventListener('input', e => {
            els.boxLabel.textContent = e.target.value;
        });

        els.showLabel.addEventListener('change', e => {
            els.boxLabel.style.display = e.target.checked ? 'block' : 'none';
        });
        
        els.fontSize.addEventListener('input', e => {
            els.boxLabel.style.fontSize = `${e.target.value}px`;
            els.fontSizeVal.textContent = e.target.value + 'px';
        });

        els.animDuration.addEventListener('input', (e) => {
            document.documentElement.style.setProperty('--anim-duration', `${e.target.value}s`);
            els.animDurationVal.textContent = e.target.value + 's';
        });

        // Quality settings functions
        function updateRecordCanvasSize() {
            const preset = els.qualityPreset.value;
            if (preset === 'native' && bgImage) {
                // Use native image size
                els.recordCanvas.width = bgImage.width;
                els.recordCanvas.height = bgImage.height;
            } else if (QUALITY_PRESETS[preset]) {
                // Use preset dimensions
                const [width, height] = QUALITY_PRESETS[preset];
                els.recordCanvas.width = width;
                els.recordCanvas.height = height;
            }
            updateQualityInfo();
        }

        function updateQualityInfo() {
            const width = els.recordCanvas.width;
            const height = els.recordCanvas.height;
            const fps = parseInt(els.fps.value) || 30;
            els.qualityInfo.textContent = `${width}x${height} @ ${fps}fps`;
        }

        els.qualityPreset.addEventListener('change', () => {
            const preset = els.qualityPreset.value;
            els.qualityPresetVal.textContent = preset === 'native' ? 'Native' : 
                                              preset === '4k' ? '4K' : 
                                              preset + 'p';
            if (bgImage) {
                updateRecordCanvasSize();
            } else {
                // Default size if no image loaded
                if (preset !== 'native') {
                    const [width, height] = QUALITY_PRESETS[preset];
                    els.recordCanvas.width = width;
                    els.recordCanvas.height = height;
                }
                updateQualityInfo();
            }
        });

        els.bitrate.addEventListener('input', (e) => {
            els.bitrateVal.textContent = e.target.value;
        });

        els.fps.addEventListener('input', (e) => {
            els.fpsVal.textContent = e.target.value;
            updateQualityInfo();
        });

        const updateSelected = () => {
            if (!activeElement) return;
            const rgba = hexToRgba(els.boxColor.value, els.boxOpacity.value);
            
            els.boxOpacityVal.textContent = parseFloat(els.boxOpacity.value).toFixed(2);
            updateRgbaDisplay();
            els.borderWidthVal.textContent = els.borderWidth.value + 'px';
            els.posXVal.textContent = els.posX.value;
            els.posYVal.textContent = els.posY.value;
            els.rectWidthVal.textContent = els.rectWidth.value + 'px';
            els.rectHeightVal.textContent = els.rectHeight.value + 'px';

            activeElement.style.left = els.posX.value + 'px';
            activeElement.style.top = els.posY.value + 'px';
            activeElement.style.width = els.rectWidth.value + 'px';
            activeElement.style.height = els.rectHeight.value + 'px';

            // Rotation
            const rotation = els.rotation.value;
            els.rotationVal.textContent = rotation + '°';
            activeElement.style.transform = `rotate(${rotation}deg)`;

            // Z-Index
            activeElement.style.zIndex = els.zIndex.value;
            els.zIndexVal.textContent = els.zIndex.value;

            if (activeElement.id === 'highlight-box') {
                // For highlight-box, apply opacity to background color (rgba), not element opacity
                const rgba = hexToRgba(els.boxColor.value, els.boxOpacity.value);
                activeElement.style.backgroundColor = rgba;
                activeElement.style.borderColor = els.boxColor.value;
                activeElement.style.borderWidth = `${els.borderWidth.value}px`;
                // Ensure element opacity is 1 (full) so only color opacity applies
                activeElement.style.opacity = '1';
                
                // Label color
                els.boxLabel.style.color = els.labelColor.value;
            } else if (activeElement.dataset.customSvg === 'true') {
                // Custom SVG element - apply opacity to color using rgba, not element opacity
                const rgba = hexToRgba(els.boxColor.value, els.boxOpacity.value);
                activeElement.style.color = rgba;
                // Ensure element opacity is 1 (full) so only color opacity applies
                activeElement.style.opacity = '1';
                const svg = activeElement.querySelector('svg');
                if (svg) {
                    // Update fill to currentColor only if fill is not "none"
                    if (svg.hasAttribute('fill')) {
                        const fillValue = svg.getAttribute('fill');
                        if (fillValue && fillValue !== 'none') {
                            svg.setAttribute('fill', 'currentColor');
                        }
                    }
                    svg.querySelectorAll('[fill]').forEach(el => {
                        const fillValue = el.getAttribute('fill');
                        if (fillValue && fillValue !== 'none') {
                            el.setAttribute('fill', 'currentColor');
                        }
                    });
                    
                    // Update stroke to currentColor only if stroke is not "none"
                    if (svg.hasAttribute('stroke')) {
                        const strokeValue = svg.getAttribute('stroke');
                        if (strokeValue && strokeValue !== 'none') {
                            svg.setAttribute('stroke', 'currentColor');
                        }
                    }
                    svg.querySelectorAll('[stroke]').forEach(el => {
                        const strokeValue = el.getAttribute('stroke');
                        if (strokeValue && strokeValue !== 'none') {
                            el.setAttribute('stroke', 'currentColor');
                        }
                    });
                    
                    // Also update the cached SVG for video recording
                    if (activeElement.dataset.svgImageData) {
                        URL.revokeObjectURL(activeElement.dataset.svgImageData);
                        delete activeElement.dataset.svgImageData;
                        delete activeElement._cachedSvgImage;
                        // Re-cache the SVG with new color - replace currentColor with actual color
                        const svgEl = activeElement.querySelector('svg');
                        if (svgEl) {
                            let svgData = new XMLSerializer().serializeToString(svgEl);
                            // Replace currentColor with the actual RGBA color for image rendering
                            svgData = replaceCurrentColorInSvgXml(svgData, rgba);
                            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                            const url = URL.createObjectURL(svgBlob);
                            const img = new Image();
                            img.onload = () => {
                                activeElement.dataset.svgImageData = url;
                                activeElement._cachedSvgImage = img;
                            };
                            img.src = url;
                        }
                    }
                }
            } else {
                // Arrow element - apply opacity to color using rgba, not element opacity
                const rgba = hexToRgba(els.boxColor.value, els.boxOpacity.value);
                activeElement.style.color = rgba;
                // Ensure element opacity is 1 (full) so only color opacity applies
                activeElement.style.opacity = '1';
                activeElement.dataset.arrowSize = els.borderWidth.value;
                activeElement.dataset.type = els.arrowType.value;
                const path = activeElement.querySelector('path');
                if (path) {
                    path.setAttribute('d', ARROW_PATHS[els.arrowType.value]);
                }
            }
        };

        els.boxColor.addEventListener('input', () => {
            updateRgbaDisplay();
            updateSelected();
        });
        els.boxOpacity.addEventListener('input', () => {
            updateRgbaDisplay();
            updateSelected();
        });
        els.rgbaInput.addEventListener('paste', (e) => {
            // Handle paste event - parse after paste
            setTimeout(() => {
                const pastedValue = e.target.value;
                if (!parseRgbaInput(pastedValue)) {
                    // If parsing fails, restore the correct value
                    updateRgbaDisplay();
                }
            }, 0);
        });
        els.rgbaInput.addEventListener('blur', (e) => {
            // Parse and apply RGBA when user finishes typing
            if (!parseRgbaInput(e.target.value)) {
                // If parsing fails, restore the correct value
                updateRgbaDisplay();
            }
        });
        els.rgbaInput.addEventListener('keypress', (e) => {
            // Allow Enter key to apply
            if (e.key === 'Enter') {
                e.preventDefault();
                e.target.blur();
            }
        });
        els.borderWidth.addEventListener('input', updateSelected);
        els.arrowType.addEventListener('change', updateSelected);
        els.posX.addEventListener('input', updateSelected);
        els.posY.addEventListener('input', updateSelected);
        els.rectWidth.addEventListener('input', updateSelected);
        els.rectHeight.addEventListener('input', updateSelected);
        els.rotation.addEventListener('input', updateSelected);
        els.zIndex.addEventListener('input', updateSelected);
        els.labelColor.addEventListener('input', () => {
            if (activeElement && activeElement.id === 'highlight-box') {
                els.boxLabel.style.color = els.labelColor.value;
            }
        });

        const applyAnimClass = (className) => {
            const el = document.getElementById('highlight-box');
            el.classList.remove('anim-pulse', 'anim-fade', 'anim-bounce', 'anim-shake', 'anim-flash', 'anim-spin', 'anim-zoom', 'anim-float');
            if (className) el.classList.add(className);
        };

        els.btnPulse.addEventListener('click', () => {
            const el = document.getElementById('highlight-box');
            el.classList.toggle('pulse-loop');
            if(el.classList.contains('pulse-loop')) {
                applyAnimClass(els.animType.value);
                els.btnPulse.classList.replace('bg-slate-700', 'bg-red-600');
                els.btnPulse.textContent = 'STOP LOOP';
            } else {
                applyAnimClass(null);
                els.btnPulse.classList.replace('bg-red-600', 'bg-slate-700');
                els.btnPulse.textContent = 'LOOP';
            }
        });

        function setupDraggable(element) {
            let isDragging = false;
            let isResizing = false;
            let startX, startY, startW, startH, startL, startT;
            element.addEventListener('mousedown', e => {
                setActive(element);
                const handle = element.querySelector('.resize-handle');
                if (e.target === handle) { isResizing = true; } else { isDragging = true; }
                startX = e.clientX; startY = e.clientY;
                startW = element.offsetWidth; startH = element.offsetHeight;
                startL = element.offsetLeft; startT = element.offsetTop;
                const onMove = ev => {
                    if (isDragging) {
                        const newLeft = startL + (ev.clientX - startX);
                        const newTop = startT + (ev.clientY - startY);
                        element.style.left = `${newLeft}px`;
                        element.style.top = `${newTop}px`;
                        els.posX.value = newLeft;
                        els.posXVal.textContent = newLeft;
                        els.posY.value = newTop;
                        els.posYVal.textContent = newTop;
                    } else if (isResizing) {
                        const newWidth = startW + (ev.clientX - startX);
                        const newHeight = startH + (ev.clientY - startY);
                        element.style.width = `${newWidth}px`;
                        element.style.height = `${newHeight}px`;
                        els.rectWidth.value = newWidth;
                        els.rectWidthVal.textContent = newWidth + 'px';
                        els.rectHeight.value = newHeight;
                        els.rectHeightVal.textContent = newHeight + 'px';
                    }
                };
                const onEnd = () => { isDragging = isResizing = false; document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onEnd); };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onEnd);
            });
        }
        setupDraggable(document.getElementById('highlight-box'));

        let mediaRecorder;
        let chunks = [];
        let recordingActive = false;

        function renderFrame() {
            if (!recordingActive) return;
            // Ensure high-quality rendering is enabled each frame
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, els.recordCanvas.width, els.recordCanvas.height);
            if (bgImage) {
                // Use high-quality image scaling
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(bgImage, 0, 0, els.recordCanvas.width, els.recordCanvas.height);
            }
            const captureRect = els.canvasWrapper.getBoundingClientRect();
            elements.forEach(el => {
                const style = window.getComputedStyle(el);
                if (style.display === 'none') return;
                
                const sx = els.recordCanvas.width / captureRect.width;
                const sy = els.recordCanvas.height / captureRect.height;
                
                const x = el.offsetLeft * sx;
                const y = el.offsetTop * sy;
                const w = el.offsetWidth * sx;
                const h = el.offsetHeight * sy;
                
                ctx.save();
                ctx.globalAlpha = parseFloat(style.opacity);
                const transform = style.transform;
                if (transform && transform !== 'none') {
                    const matrix = transform.match(/matrix\((.+)\)/);
                    if (matrix) {
                        const v = matrix[1].split(', ').map(parseFloat);
                        ctx.translate(x + w/2, y + h/2);
                        ctx.transform(v[0], v[1], v[2], v[3], 0, 0);
                        ctx.translate(-(x + w/2), -(y + h/2));
                    }
                }
                if (el.id === 'highlight-box') {
                    ctx.fillStyle = style.backgroundColor; ctx.fillRect(x, y, w, h);
                    const bW = parseInt(style.borderWidth) * sx;
                    if (bW > 0) { ctx.strokeStyle = style.borderColor; ctx.lineWidth = bW; ctx.strokeRect(x, y, w, h); }
                    
                    // Fix: Use correct text content and calculated scale for font
                    if (els.showLabel.checked) {
                        ctx.fillStyle = 'white';
                        const currentFontSize = parseInt(style.fontSize) || 14;
                        ctx.font = `bold ${currentFontSize * sy}px sans-serif`;
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(els.boxLabel.textContent, x + w/2, y + h/2);
                    }
                } else if (el.dataset.customSvg === 'true') {
                    // Custom SVG element - use pre-loaded cached image
                    const svgElement = el.querySelector('svg');
                    if (svgElement) {
                        // Use cached Image object if available (synchronous drawing)
                        if (el._cachedSvgImage && el._cachedSvgImage.complete) {
                            // Image is loaded, draw it synchronously
                            ctx.globalAlpha = 1; // Opacity is in the color (rgba)
                            ctx.drawImage(el._cachedSvgImage, x, y, w, h);
                        } else {
                            // Fallback: try to load/cache if not already cached
                            let imgUrl = el.dataset.svgImageData;
                            if (!imgUrl) {
                                // Serialize SVG to data URL - replace currentColor with actual color
                                let svgData = new XMLSerializer().serializeToString(svgElement);
                                const actualColor = el.style.color || 'rgba(0, 0, 0, 1)'; // Get color from element
                                svgData = replaceCurrentColorInSvgXml(svgData, actualColor);
                                const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                                imgUrl = URL.createObjectURL(svgBlob);
                                el.dataset.svgImageData = imgUrl;
                            }
                            
                            // If no cached image, try to create and cache it
                            if (!el._cachedSvgImage) {
                                const img = new Image();
                                img.onload = () => {
                                    el._cachedSvgImage = img;
                                };
                                img.src = imgUrl;
                            }
                        }
                    }
                } else {
                    // Arrow element
                    ctx.fillStyle = style.color;
                    const type = el.dataset.type || 'simple';
                    const pathStr = ARROW_PATHS[type];
                    const path = new Path2D(pathStr);
                    ctx.translate(x, y); ctx.scale(w / 24, h / 24); ctx.fill(path);
                }
                ctx.restore();
            });
            requestAnimationFrame(renderFrame);
        }

        const startRec = () => {
            recordingActive = true; chunks = []; document.body.classList.add('is-recording');
            
            // Ensure canvas size is updated based on quality preset
            if (bgImage) {
                updateRecordCanvasSize();
            }
            
            const fps = parseInt(els.fps.value) || 30;
            const stream = els.recordCanvas.captureStream(fps);
            
            // MediaRecorder options with bitrate
            const bitrateMbps = parseInt(els.bitrate.value);
            const bitrateBps = bitrateMbps * 1000000; // Convert Mbps to bps
            
            const options = { 
                mimeType: 'video/webm',
                videoBitsPerSecond: bitrateBps
            };
            
            // Try to use bitrate if supported, fallback to default
            let supportedMimeType = 'video/webm';
            if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                supportedMimeType = 'video/webm;codecs=vp9';
            } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                supportedMimeType = 'video/webm;codecs=vp8';
            }
            options.mimeType = supportedMimeType;
            
            mediaRecorder = new MediaRecorder(stream, options);
            mediaRecorder.ondataavailable = e => {
                if (e.data && e.data.size > 0) {
                    chunks.push(e.data);
                }
            };
            mediaRecorder.onstop = () => {
                const blob = new Blob(chunks, { type: supportedMimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); 
                a.href = url; 
                a.download = `plan-asset-${Date.now()}.webm`; 
                a.click();
            };
            mediaRecorder.start(100); // Request data every 100ms for better quality
            renderFrame();
        };

        const stopRec = () => { 
            if(mediaRecorder && mediaRecorder.state === 'recording') {
                // Request final chunk to ensure all frames are captured
                mediaRecorder.requestData();
                // Small delay to ensure the final chunk is processed before stopping
                setTimeout(() => {
                    recordingActive = false;
                    mediaRecorder.stop();
                    document.body.classList.remove('is-recording');
                }, 50);
            } else {
                recordingActive = false;
                document.body.classList.remove('is-recording');
            }
        };

        els.btnStart.addEventListener('click', () => {
            if (!recordingActive) { startRec(); els.btnStart.textContent = "STOP RECORDING"; els.btnStart.classList.replace('bg-blue-600', 'bg-red-600'); } else { stopRec(); els.btnStart.textContent = "RECORD VIDEO"; els.btnStart.classList.replace('bg-red-600', 'bg-blue-600'); }
        });

        els.btnMagic.addEventListener('click', () => {
            if (recordingActive) return;
            startRec();
            const el = document.getElementById('highlight-box');
            const selectedAnim = els.animType.value;
            el.classList.remove(selectedAnim);
            void el.offsetWidth;
            el.classList.add(selectedAnim);
            // Add small buffer (100ms) to ensure all frames are captured at 30fps
            // This accounts for frame boundaries and MediaRecorder chunk timing
            const durationMs = parseFloat(els.animDuration.value) * 1000;
            setTimeout(stopRec, durationMs + 100);
        });

        function hexToRgba(hex, alpha) { const r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }
        els.btnToggle.addEventListener('click', () => { const isHidden = document.getElementById('highlight-box').classList.toggle('hidden-box'); els.btnToggle.textContent = isHidden ? 'SHOW BOX' : 'HIDE BOX'; });
        els.btnPulseOnce.addEventListener('click', () => {
            const el = document.getElementById('highlight-box');
            const selectedAnim = els.animType.value;
            el.classList.remove(selectedAnim); void el.offsetWidth; el.classList.add(selectedAnim);
            if(!el.classList.contains('pulse-loop')) { setTimeout(() => el.classList.remove(selectedAnim), parseFloat(els.animDuration.value) * 1000); }
        });
        els.btnReset.addEventListener('click', () => location.reload());
        els.btnDownload.addEventListener('click', async () => {
            document.body.classList.add('taking-screenshot');
            const canvas = await html2canvas(els.canvasWrapper, { backgroundColor: '#1e293b', scale: 2 });
            const a = document.createElement('a'); a.download = 'plan.png'; a.href = canvas.toDataURL(); a.click();
            document.body.classList.remove('taking-screenshot');
        });

        // Initialize quality info on page load
        updateQualityInfo();
        els.qualityPresetVal.textContent = '1080p';
        els.bitrateVal.textContent = '10';
        els.fpsVal.textContent = '30';
    </script>
</body>
</html>
</body>
</html>